extends Node

signal music_volume_changed(new_volume)
signal sfx_volume_changed(new_volume)
signal music_muted_changed(is_muted)
signal sfx_muted_changed(is_muted)
signal audio_ready # Signal emitted when audio is initialized (important for web)

# Sound bridges for web builds
var react_sound_bridge = null # Will be instantiated from a script
var audio_bridge = null # Will be instantiated from a script

# Volume ranges from 0.0 to 1.0
<<<<<<< Updated upstream
var music_volume: float = 0.0
var sfx_volume: float = 0.1
=======
var music_volume: float = 0.8:
	set(value):
		music_volume = value
		_apply_music_volume()
		_save_settings()
		music_volume_changed.emit(value)
	get:
		return music_volume

var sfx_volume: float = 0.8:
	set(value):
		sfx_volume = value
		_apply_sfx_volume()
		_save_settings()
		sfx_volume_changed.emit(value)
	get:
		return sfx_volume
>>>>>>> Stashed changes

# Mute states
var music_muted: bool = false:
	set(value):
		music_muted = value
		_apply_music_volume()
		_save_settings()
		music_muted_changed.emit(value)
	get:
		return music_muted

var sfx_muted: bool = false:
	set(value):
		sfx_muted = value
		_apply_sfx_volume()
		_save_settings()
		sfx_muted_changed.emit(value)
	get:
		return sfx_muted

# Bus indices for easier reference
var music_bus_index: int
var sfx_bus_index: int

# Default bus names
const MUSIC_BUS_NAME = "Music"
const SFX_BUS_NAME = "SFX"

var audio_initialized: bool = false

# Sound files dictionary - mapping simplified names to file paths
const SOUND_FILES = {
	"jazzNewOrleans": "res://sounds/jazz_new_orleans.mp3",
	"lofiChillJazz": "res://sounds/lofi-chill-jazz-272869.mp3",
	"buildingPlacing": "res://sounds/building_placing.wav",
	"construction": "res://sounds/construction.wav",
	"powerDrill": "res://sounds/power_drill.mp3"
}

# Current music track
var current_music: String = ""

# Currently playing audio streams (for direct Godot playback)
var music_player: AudioStreamPlayer = null
var sfx_players: Dictionary = {}

const MIN_VOLUME = -40
const MAX_VOLUME = 0
const CONFIG_PATH = "user://audio_settings.cfg"

func _ready():
	print("SoundManager: Initializing...")
	
	# Create music player for all platforms
	music_player = AudioStreamPlayer.new()
	add_child(music_player)
	
	# Set up the audio buses first
	_setup_audio_buses()
	
	# Load and apply settings
	_load_settings()
	
	# Set the music player bus
	music_player.bus = MUSIC_BUS_NAME
	
	# Initialize audio
	audio_initialized = true
	
	print("SoundManager: Initialization complete")
	print("SoundManager: Music Volume: ", music_volume, " Muted: ", music_muted)
	print("SoundManager: SFX Volume: ", sfx_volume, " Muted: ", sfx_muted)
	
	# Emit the audio ready signal
	audio_ready.emit()

# Setup audio buses (doesn't start audio playback)
func _setup_audio_buses():
	# Initialize audio bus indices
	music_bus_index = AudioServer.get_bus_index(MUSIC_BUS_NAME)
	sfx_bus_index = AudioServer.get_bus_index(SFX_BUS_NAME)
	
	# If the buses don't exist yet, create them
	if music_bus_index == -1:
		# Create music bus
		music_bus_index = AudioServer.bus_count
		AudioServer.add_bus()
		AudioServer.set_bus_name(music_bus_index, MUSIC_BUS_NAME)
		AudioServer.set_bus_send(music_bus_index, "Master")
	
	if sfx_bus_index == -1:
		# Create SFX bus
		sfx_bus_index = AudioServer.bus_count
		AudioServer.add_bus()
		AudioServer.set_bus_name(sfx_bus_index, SFX_BUS_NAME)
		AudioServer.set_bus_send(sfx_bus_index, "Master")
	
	# Verify buses were created correctly
	music_bus_index = AudioServer.get_bus_index(MUSIC_BUS_NAME)
	sfx_bus_index = AudioServer.get_bus_index(SFX_BUS_NAME)
	
	# Apply initial settings
	_apply_music_volume()
	_apply_sfx_volume()
	
	# Make sure buses aren't muted by default
	if music_bus_index != -1:
		AudioServer.set_bus_mute(music_bus_index, false)
	
	if sfx_bus_index != -1:
		AudioServer.set_bus_mute(sfx_bus_index, false)

# Process sound state received from JavaScript
func process_js_audio_state(state: Dictionary):
	# Update local state based on received data
	if state.has("musicVolume"):
		music_volume = state.musicVolume
	if state.has("sfxVolume"):
		sfx_volume = state.sfxVolume
	if state.has("musicMuted"):
		music_muted = state.musicMuted
	if state.has("sfxMuted"):
		sfx_muted = state.sfxMuted
	if state.has("currentMusic"):
		current_music = state.currentMusic
	
	# Emit signals about changes
	music_volume_changed.emit(music_volume)
	sfx_volume_changed.emit(sfx_volume)
	music_muted_changed.emit(music_muted)
	sfx_muted_changed.emit(sfx_muted)

# Called when ReactSoundBridge reports it's ready
func _on_react_audio_ready():
	print("ReactSoundBridge reports ready")
	audio_initialized = true
	
	# Update local state from React
	if react_sound_bridge != null:
		if react_sound_bridge.get("music_volume") != null:
			music_volume = react_sound_bridge.music_volume
		if react_sound_bridge.get("sfx_volume") != null:
			sfx_volume = react_sound_bridge.sfx_volume
		if react_sound_bridge.get("music_muted") != null:
			music_muted = react_sound_bridge.music_muted
		if react_sound_bridge.get("sfx_muted") != null:
			sfx_muted = react_sound_bridge.sfx_muted
		if react_sound_bridge.get("current_music") != null:
			current_music = react_sound_bridge.current_music
	
	# Emit the audio ready signal
	audio_ready.emit()

# Called when AudioBridge connects to the platform-one sound manager
func _on_audio_bridge_connected(is_connected: bool):
	print("AudioBridge connected: ", is_connected)
	
	if is_connected:
		audio_initialized = true
		
		# Request the sound state from the platform-one sound manager
		if audio_bridge.has_method("get_sound_state"):
			audio_bridge.get_sound_state()
		
		# Emit the audio ready signal
		audio_ready.emit()

# Called when any user interaction happens in web builds
func _on_user_interaction(_arg=null):
	if OS.has_feature("web") and not audio_initialized:
		_initialize_web_audio()

# Process input events directly
func _input(event):
	if OS.has_feature("web") and not audio_initialized:
		if event is InputEventMouseButton or event is InputEventKey:
			if event.pressed:
				_initialize_web_audio()
				
# If this method is called from JavaScript, it will help the game to 
# initialize audio properly in web builds
func init_web_audio_from_js():
	pass
	#if OS.has_feature("web") and not audio_initialized:
		#_initialize_web_audio()

# Initialize audio for web builds
func _initialize_web_audio():
	if audio_initialized:
		return
		
	# For web builds, we notify JavaScript to initialize audio
#	if OS.has_feature("web"):
#		JSBridge.JavaScriptGlobal.handle_audio_action("INITIALIZE_AUDIO")
#		
#		# We don't need to create any dummy players, as JavaScript will handle the audio
#		audio_initialized = true
#		audio_ready.emit()
#		return
	
	# For non-web platforms, initialize Godot audio (this shouldn't get called)
#	if not OS.has_feature("web"):
		# Set the flag to prevent multiple initializations
		audio_initialized = true
		audio_ready.emit()

# Play background music
func play_music(sound_name: String, loop: bool = true):
	if not audio_initialized:
		return
		
	# Store the current music name
	current_music = sound_name
	
	# For web builds, try multiple bridge options
#	if OS.has_feature("web"):
#		# Try AudioBridge first (platform-one integration)
#		if audio_bridge != null and audio_bridge.get("is_connected") == true:
#			print("Using AudioBridge to play music: ", sound_name)
#			if audio_bridge.has_method("play_music") and audio_bridge.play_music(sound_name):
#				return
#		
#		# Fall back to JavaScript Bridge
#		print("Using JavaScriptBridge to play music: ", sound_name)
#		JSBridge.JavaScriptGlobal.handle_audio_action("PLAY_MUSIC", sound_name)
#		return
	
	# For native builds, use Godot audio
	if not SOUND_FILES.has(sound_name):
		return
		
	# Get the file path
	var file_path = SOUND_FILES[sound_name]
	
	# Load the audio stream
	var stream = load(file_path)
	if stream == null:
		return
	
	# Stop current music if playing
	if music_player.playing:
		music_player.stop()
	
	# Set up and play the music
	music_player.stream = stream
	music_player.bus = MUSIC_BUS_NAME
	
	# Set looping if supported by the stream
	if stream is AudioStreamMP3 or stream is AudioStreamOggVorbis:
		stream.loop = loop
	
	# Ensure volume is set correctly before playing
	_apply_music_volume()
	
	# Play the music
	music_player.play()

# Play a sound effect
func play_sfx(sound_name: String):
	if not audio_initialized:
		return
		
	# For web builds, try multiple bridge options
	#if OS.has_feature("web"):
		## Try AudioBridge first (platform-one integration)
		#if audio_bridge != null and audio_bridge.get("is_connected") == true:
			#print("Using AudioBridge to play sfx: ", sound_name)
			#if audio_bridge.has_method("play_sfx") and audio_bridge.play_sfx(sound_name):
				#return
		#
		## Fall back to JavaScript Bridge
		#print("Using JavaScriptBridge to play sfx: ", sound_name)
		#JSBridge.JavaScriptGlobal.handle_audio_action("PLAY_SFX", sound_name)
		#return
	
	# For native builds, use Godot audio
	if not SOUND_FILES.has(sound_name):
		return
		
	# Get the file path
	var file_path = SOUND_FILES[sound_name]
	
	# Load the audio stream
	var stream = load(file_path)
	if stream == null:
		return
	
	# Create or reuse a player for this sound
	var player: AudioStreamPlayer
	if not sfx_players.has(sound_name):
		player = AudioStreamPlayer.new()
		add_child(player)
		sfx_players[sound_name] = player
	else:
		player = sfx_players[sound_name]
		if player.playing:
			player.stop()
	
	# Set up and play the sound
	player.stream = stream
	if sfx_muted:
		player.volume_db = linear_to_db(0)
	else:
		player.volume_db = linear_to_db(sfx_volume)
	player.bus = SFX_BUS_NAME
	player.play()

# Stop background music
func stop_music():
	if not audio_initialized:
		return
		
	# For web builds, try multiple bridge options
	#if OS.has_feature("web"):
		## Try AudioBridge first (platform-one integration)
		#if audio_bridge != null and audio_bridge.get("is_connected") == true:
			#print("Using AudioBridge to stop music")
			#if audio_bridge.has_method("stop_music") and audio_bridge.stop_music():
				#current_music = ""
				#return
		#
		## Fall back to JavaScript Bridge
		#print("Using JavaScriptBridge to stop music")
		#JSBridge.JavaScriptGlobal.handle_audio_action("STOP_MUSIC")
		#current_music = ""
		#return
	
	# For native builds, use Godot audio
	if music_player and music_player.playing:
		music_player.stop()
	
	current_music = ""

# Set music volume (0.0 to 1.0)
func set_music_volume(volume: float):
	music_volume = clampf(volume, 0.0, 1.0)
	
	# For web builds, try multiple bridge options
	if false:
		pass
#	if OS.has_feature("web"):
#		# Try AudioBridge first (platform-one integration)
#		if audio_bridge != null and audio_bridge.get("is_connected") == true:
#			print("Using AudioBridge to set music volume: ", music_volume)
#			if audio_bridge.has_method("set_music_volume"):
#				audio_bridge.set_music_volume(music_volume)
#		else:
#			# Fall back to JavaScript Bridge
#			print("Using JavaScriptBridge to set music volume: ", music_volume)
#			JSBridge.JavaScriptGlobal.handle_audio_action("SET_MUSIC_VOLUME", "", music_volume)
	else:
		# Apply to local Godot audio system
		_apply_music_volume()
	
	# Emit signal
	music_volume_changed.emit(music_volume)

# Set SFX volume (0.0 to 1.0)
func set_sfx_volume(volume: float):
	sfx_volume = clampf(volume, 0.0, 1.0)
	
	# For web builds, try multiple bridge options
#	if OS.has_feature("web"):
	if false:
		pass
#		# Try AudioBridge first (platform-one integration)
#		if audio_bridge != null and audio_bridge.get("is_connected") == true:
#			print("Using AudioBridge to set sfx volume: ", sfx_volume)
#			if audio_bridge.has_method("set_sfx_volume"):
#				audio_bridge.set_sfx_volume(sfx_volume)
#		else:
#			# Fall back to JavaScript Bridge
#			print("Using JavaScriptBridge to set sfx volume: ", sfx_volume)
#			JSBridge.JavaScriptGlobal.handle_audio_action("SET_SFX_VOLUME", "", sfx_volume)
	else:
		# Apply to local Godot audio system
		_apply_sfx_volume()
	
	# Emit signal
	sfx_volume_changed.emit(sfx_volume)

# Toggle music mute state
func toggle_music_mute():
	music_muted = !music_muted
	
	# For web builds, try multiple bridge options
#	if OS.has_feature("web"):
	if false:
		pass
#		# Try AudioBridge first (platform-one integration)
#		if audio_bridge != null and audio_bridge.get("is_connected") == true:
#			print("Using AudioBridge to toggle music mute: ", music_muted)
#			if audio_bridge.has_method("toggle_music_mute"):
#				audio_bridge.toggle_music_mute()
#		else:
#			# Fall back to JavaScript Bridge
#			print("Using JavaScriptBridge to toggle music mute: ", music_muted)
#			JSBridge.JavaScriptGlobal.handle_audio_action("TOGGLE_MUSIC_MUTE")
	else:
		# Apply to local Godot audio system
		_apply_music_volume()
	
	# Emit signal
	music_muted_changed.emit(music_muted)

# Toggle SFX mute state
func toggle_sfx_mute():
	sfx_muted = !sfx_muted
	
	# For web builds, try multiple bridge options
#	if OS.has_feature("web"):
	if false:
		pass
#		# Try AudioBridge first (platform-one integration)
#		if audio_bridge != null and audio_bridge.get("is_connected") == true:
#			print("Using AudioBridge to toggle sfx mute: ", sfx_muted)
#			if audio_bridge.has_method("toggle_sfx_mute"):
#				audio_bridge.toggle_sfx_mute()
#		else:
#			# Fall back to JavaScript Bridge
#			print("Using JavaScriptBridge to toggle sfx mute: ", sfx_muted)
#			JSBridge.JavaScriptGlobal.handle_audio_action("TOGGLE_SFX_MUTE")
	else:
		# Apply to local Godot audio system
		_apply_sfx_volume()
	
	# Emit signal
	sfx_muted_changed.emit(sfx_muted)

# Apply music volume settings
func _apply_music_volume():
	if not audio_initialized:
		return
		
	var db = linear_to_db(music_volume)
	print("SoundManager: Applying music volume: ", music_volume, " (", db, "dB)")
	
	if music_bus_index != -1:
		AudioServer.set_bus_mute(music_bus_index, music_muted)
		if not music_muted:
			AudioServer.set_bus_volume_db(music_bus_index, db)
	
	if music_player != null:
		music_player.volume_db = -80.0 if music_muted else db

# Apply SFX volume settings
func _apply_sfx_volume():
	if not audio_initialized:
		return
		
	var db = linear_to_db(sfx_volume)
	print("SoundManager: Applying SFX volume: ", sfx_volume, " (", db, "dB)")
	
	if sfx_bus_index != -1:
		AudioServer.set_bus_mute(sfx_bus_index, sfx_muted)
		if not sfx_muted:
			AudioServer.set_bus_volume_db(sfx_bus_index, db)
	
	for player in sfx_players.values():
		if player != null:
			player.volume_db = -80.0 if sfx_muted else db

# Helper function to convert linear volume to decibels
func linear_to_db(linear_value: float) -> float:
	if linear_value <= 0:
		return -80.0
	return 20.0 * log(linear_value) / log(10.0)

func _load_settings():
	print("SoundManager: Loading settings from ", CONFIG_PATH)
	var config = ConfigFile.new()
	var err = config.load(CONFIG_PATH)
	
	if err == OK:
		print("SoundManager: Successfully loaded settings file")
		# Load saved values
		music_volume = config.get_value("audio", "music_volume", 0.8)
		sfx_volume = config.get_value("audio", "sfx_volume", 0.8)
		music_muted = config.get_value("audio", "music_muted", false)
		sfx_muted = config.get_value("audio", "sfx_muted", false)
	else:
		print("SoundManager: No settings file found, using defaults")
		# Set default values
		music_volume = 0.8
		sfx_volume = 0.8
		music_muted = false
		sfx_muted = false
		# Save the default values
		_save_settings()
	
	print("SoundManager: Loaded values - Music: ", music_volume, " SFX: ", sfx_volume)
	
	# Apply the loaded settings immediately
	_apply_music_volume()
	_apply_sfx_volume()

func _save_settings():
	print("SoundManager: Saving settings...")
	var config = ConfigFile.new()
	
	# Save current values
	config.set_value("audio", "music_volume", music_volume)
	config.set_value("audio", "sfx_volume", sfx_volume)
	config.set_value("audio", "music_muted", music_muted)
	config.set_value("audio", "sfx_muted", sfx_muted)
	
	# Save to file
	var err = config.save(CONFIG_PATH)
	if err == OK:
		print("SoundManager: Settings saved successfully")
	else:
		print("SoundManager: Error saving settings: ", err)

func get_music_volume() -> float:
	if music_muted:
		return MIN_VOLUME
	return music_volume

func get_sfx_volume() -> float:
	if sfx_muted:
		return MIN_VOLUME
	return sfx_volume
